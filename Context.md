# Содержание

**Задача**: спроектировать систему заказа и доставки пластиковой карты

Используем 4 блока:

## Определим требования (5 мин)

1. Соберем требования
   1. Цели бизнеса и ключевые  метрики и критерии
   2. Бизнес ограничения
   3. Ожидания юзеров

2. Декомпозируем по бизнес сценариям:
   1. основной для каждого домена
   2. ошибочные
   3. альтернативные - в основном позволяющие обойти ошибочные сценарии (через саппорт)
   4. сценарии после доставки - выпуск доп карт, замена карт итд

## Определим модель данных (10 мин)

1. Определим домены - если делим то делаем 2 модели, если домен один, то делаем общую модель
2. Составим примерный DTO JSON  

```json
{
    "orderId": "1023920310232327",  //его можно использовать для идемпотентности?
    "cardInfo": "1023920310232327",
    "userInfo": "1023920310232327",
    "ligalInfo": "1023920310232327",
    "deliveryInfo": "1023920310232327",
    "timestamp": "1023920310232327"
}
```

3. Раскидаем примерно на таблицы данных в БД
   1. *orders_table*
   2. *users_table*
   3. *cards__table*
   4. *deliveries_table*

4. Создать запрос SQL: который выведет список пользователей из таблицы users, которые имеют карту с типом 'credit'. Список отсортировать по дате регистрации (представим≤ что БД денормализована)

```sql
select distinct user_id from users
where card_type = 'credit'
order by created_at desc
```

5. *В чем смысл теорем ACID, CAP?*

## Определим взаимодействие между системами (15 мин)

1. Какой протокол выберем - **rest / rpc / grpc / soap**
2. Распишем примерный контракт взаимодействия между фронтом и бэкендом
   1. */createOrder*
   2. */updateOrder*
   3. */cancelOrder*
   4. */getOrderStatusById*

3. Написал контракт - надо поревьюить https://raw.githubusercontent.com/konkrr/hiring-tasks/main/card-delivery-openapi.yaml

4. Фронтенд должен в real time обновлять статус готовности заявки на карту. Какую логику нужно применить для запроса */getStatus* (polling / long polling или websocket)



## Взаимодействие между доменами (10 мин)

Мы используем Event Sourcing для взаимодействия между системами. Нам не так важна консистентность данных, сколько важна надежность системы. 

1. Какие еще способы интеграции можно использовать? (брокеры, БД, rpc-протоколы)
2. В чем преимущества Event Sourcing и асинхронного взаимодействия?
   1. Преимущества:
      1. История изменений для аудита и анализа.
      2. Воссоздание состояния в любой момент времени.
      3. Возможность масштабирования и распределенности.
   2. Недостатки:
      1. Сложность реализации и отладки.
      2. Проблема eventual consistancy - итоговая консистентность системы

3. *Как реализовать exactly-once отправку запроса/заявки? (идемпотентность фронт/бэк, reply на сетевые ошибки)*
   1. *Это работает, когда наш запрос не дошел и мы отправили новый. А что делать когда запрос дошел и успешно обработался, но мы не получили ответ?*