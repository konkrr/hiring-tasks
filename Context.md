# Содержание

**Задача**: спроектировать систему заказа и доставки пластиковой карты. Распределили между 2мя командами: команда заказа и команда delivery

Используем 4 блока:

## Определим требования (5 мин)

1. Соберем требования

**Ожидаем услышать**
   1. Цели бизнеса и ключевые метрики и критерии
   2. Бизнес ограничения
   3. Нефункциональные требования к системе (нагрузка, масштабирование БД и сервисов, способы взаимодействия внутри и снаружи домена)
   4. Ожидания юзеров

## Определим дизайн (10 мин)

Нарисуем примерный дизайн микросервисной архитектуры и ее компонентов несколько вариантов дизайна
<img width="672" alt="image" src="https://github.com/konkrr/hiring-tasks/assets/46089685/c81451a9-8bea-4ffa-990e-d0ea23fdeca7">

**Наводящие вопросы**
1. Давай определим домены и декомпозируем систему (DDD) - как можно разделить на ограниченные контексты?
- по ключевым данным системы
- по процессам
- регуляторные и лицензионные требования (GDPR, PCI итд)
- по юзер сценариям
- по связности с другими элементами, частоте обновлений компонент

2. Декомпозиция по процессам
1. Internal/External API 
2. statefull и stateless - по состоянию объектов
    - stateless - без сохранения состояния http/rpc и все фоновые службы (автономия клиента). Нужна автономность в отношении данных. Чаще строятся на API службах
    - statefull - требующие бизнес-логики, статусных моделей, идемпотентности, дополнительных вызовов сервер->клиент. Большое внимание к потере данных. Statefull мониторят состояние клиента либо логику процесса. Для стейтфул нужна синхронизация состояний между сервисами
По сценариям с данными
Разделение чтения/записи через CQRS
Высокая доступность чтения - нужно много реплик в разных ЦОД
Высокая доступность записи - версионирование записей и решение конфликтов 
Разделение на характер данных (холодные, горячие данные)
2. Декомпозиция по сценариям - между доменами существуют связанные сценарии?
знаком ли с паттерном SAGA? 
SAGA относится к оркестрации или к хореографии? 
Где можно расположить логику оркестрации?


Нужно 


Посмотрим что надо добавить если кол-во юзеров/запросов резко масштабируется?

Как ограничить нагрузку? (rate limiter)

Как избежать от дублирования запросов в системе? 
- обеспечить идемпотентность при обработке. Идемпотентность хорошо работает, когда наш запрос не дошел и мы отправили новый. А что делать когда запрос дошел и успешно обработался на сервере, но мы не получили его ответ? (с подвохом)
- обеспечить защиту на фронте
- обеспечить обработку неуспешных запросов через retry (с тамаутами, без ответа, с ошибочными ответами)

Как обеспечить равномерную нагрузку на сервера/БД? 
- использовать вертикальное и горизонтальное масштабирование сервисов
- использовать шардирование БД. Как обеспечить равномерное распределение данных между шардами? (по признаку, по хэшу через консистентное хэширование (sticky сессии))

Как избежать состояния гонки? У нас высокий параллелизм запросов к БД и возникают конфликты при записи одних и тех же значений. Как их избежать? (оптимистичные, пессимистичные блокировки, констрейнты БД через арифметику или enum, скрипт Lua, упорядоченные множества Redis)

Как обеспечить доступность и надежность - репликация по разным ЦОД (всего четное число для корректной работы алгоритмов согласованности)

Как обеспечить согласованность? (по кворуму части голосов от реплик. Можно регулировать от слабой до сильной согласованности. Есть отложенная согласованность или согласованность на основании версионирования)


3. *Как реализовать exactly-once отправку запроса/заявки?
   1. *Это работает, когда наш запрос не дошел и мы отправили новый. А что делать когда запрос дошел и успешно обработался, но мы не получили ответ?*


Как обеспечить fail tolerance восстановление - нужна система обнаружения сбоев (децентрализованный gossip protocol) или circut breaker (централизованный). 

По платформам и способу взаимодействия - websocket и streams
  


## Определим модель данных (10 мин)

2. Составим примерный DTO JSON  

```json
{
    "orderId": "1023920310232327",  //его можно использовать для идемпотентности?
    "cardInfo": "1023920310232327",
    "userInfo": "1023920310232327",
    "ligalInfo": "1023920310232327",
    "deliveryInfo": "1023920310232327",
    "timestamp": "1023920310232327"
}
```

4. Добавляем БД - общую или для каждого сервиса.  По сценариям чтения/записи (холодное, архив, горячее), масштабирование и доступность (репликация и сегментирование). Есть реплики (CQRS)? Надо  добавить кэш/CDN? 
    - строчные бд используем для общих данных. Репликация и сегментирование обеспечат масштабирование и доступность. 
    - распределенные данные или большие объемы - используем ключ-значение и комбинируем
    - колоночные бд используем для событийных данных или агрегатов, с аналитическими выборками


3. Давай раскидаем данные по таблицам в БД. Разрабы говорят что надо нормализовать БД а аналитики DWH говорят что надо все в одну таблицу сложить - кого слушать? 
   1. *orders_table*
   2. *users_table*
   3. *cards__table*
   4. *deliveries_table*

4. Создать запрос SQL: подсчитать кол-во пользователей из таблицы users, которые имеют карту с типом 'credit' (представим≤ что БД денормализована)

```sql
select count(distinct user_id) from users
where card_type = 'credit'
```

5. *В чем смысл теорем ACID, CAP?*

6. 7. Монотонное чтение (Eventual Consistency - PRAM) - чтение всегда из одной реплики либо гарантировать последний ответ на большинстве реплик. Читаем всегда последний ответ. 
8. Монотонная запись (Eventual Consistency - PRAM) - для наблюдателя запись всегда происходит в порядке появления событий. Упорядочивание сообщений есть на уровне TCP
9. Чтение своих событий (Eventual Consistency - PRAM) - юзер может сразу прочитать данные, которые записал. Либо через кэш, который инвалидируется после репликации. Либо в домен чтения пишутся данные параллельно. 
10. Фантомные эффекты в БД - разные уровни изоляции БД позволяют их избежать. Либо Apend Only полное разделение чтения и записи



## Определим взаимодействие между системами (15 мин)

1. Какой протокол выберем - **rest / rpc / grpc / graphql / soap**

2. Распишем примерный контракт взаимодействия с заявкой (на выбранном протоколе)
3. если REST то смотрим на правильную структуру запроса как ресурс /api/v1/order и правильный выбор методов
4. если rpc то смотрим на правильный выбор команд
5. как версионировать запросы?
6. где в запросе можно передавать параметры? (path, query, boby, header)

7. У нас есть контракт от джуна - надо поревьюить и найти несколько ошибок https://raw.githubusercontent.com/konkrr/hiring-tasks/main/card-delivery-openapi.yaml

8. Фронтенд должен в real time обновлять статус готовности заявки на карту. Какую логику нужно применить для запроса */getStatus* (polling / long polling или websocket)

9. Выделить способ взаимодействия между сервисами. Синхронный (REST/RPC) можно использовать в ограниченных контекстах. Ассинхронный (брокеры, Кафка) можно использовать между ограниченными контекстами. Описать какие протоколы будем использовать и почему - запрос/команда/событие
- Синхронные - HTTP short/long polling, WebSocket, Stream (только клиент-сервер)
- Асинхронные - брокеры и кафка




## Взаимодействие между доменами (10 мин)


1. Какие еще способы интеграции можно использовать? (брокеры, БД, rpc-протоколы)
2. В чем преимущества Event Sourcing и микросервисной архитектуры?
3. Чем Kafka отличается от RabbitMQ?


