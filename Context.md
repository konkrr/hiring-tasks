# Содержание

**Задача**: спроектировать систему заказа и доставки пластиковой карты. Распределили между 2мя командами: команда заказа и команда delivery

Используем 4 блока: 1) определим требования 2) дизайн системы 3) посмотрим на swagger 4) подберем БД

## 1. Определим требования (5 мин)

1. Соберем требования (ожидаем вопросы от кандидата):
   1. Цели бизнеса и функциональные сценарии
   2. Бизнес ограничения
   3. Нефункциональные требования (нагрузка, масштабирование)
   4. Ожидания юзеров

#### **Опционально доп вопросы (middle+/senior)** 

1. В таком сценарии стоит вообще оценивать нагрузку QPS и объем БД?
2. Оценить сколько места в БД нам потребуется
    - MAU 3 миллионов юзеров - 30% заказывают карты = 1M 
    - объем заявки у нас примерно 1Мб (текст + скан паспорта)
    - храним данные 10 лет
    - объем данных в месяц = 1М * 1Мб = 1 Тб/месяц 
    - объем данных за 5 лет: 1Тб * 365 * 10 = ~3.5Пб

## 2. Определим дизайн (15 мин)

Нарисуем примерный дизайн системы и обсудим варианты (нужно пошарить экран и блокнот)
<img width="472" alt="image" src="https://github.com/konkrr/hiring-tasks/assets/46089685/c81451a9-8bea-4ffa-990e-d0ea23fdeca7">

1. Давай определим домены и декомпозируем систему (DDD) - как можно разделить на ограниченные контексты?
   1. по набору данных
   2. по процессам/сценариям
   3. регуляторные и лицензионные требования (GDPR, PCI итд)
   4. по связности с другими элементами, частоте обновлений компонент
2. Как внутри домена можно еще декомпозировать процессы? (+ если обратит на это внимание)  **Если не сказал6 то задать вопрос про statefull и stateless**
   1. Public/Private API (Internal/External - если используем CDN, S3)
   2. statefull и stateless - по состоянию объектов
      1. stateless - без сохранения состояния http/rpc. Требует автономность в отношении данных.
      2. statefull - требующие бизнес-логики, статусных моделей, идемпотентности, дополнительных вызовов сервер->клиент. Statefull мониторят состояние клиента либо логику процесса.
3. Сценарии работы с данными - Допустим у нас сильный перекос в сторону чтения данных происходит, то что что нам лучше сделать? **Если не сказал, то задать вопрос про CQRS** 
   1. Разделение чтения/записи через CQRS
   2. Высокая доступность чтения - нужно много реплик в разных ЦОД
   3. Высокая доступность записи - версионирование записей и решение конфликтов 
   4. Разделение на характер данных (холодные, горячие данные, архивные)
4. Какие способы интеграции можно использовать между доменами? (брокеры, общие БД, файлы, разные протоколы)
   1. В чем преимущества Event Sourcing и микросервисной архитектуры?
   2. Чем Kafka отличается от RabbitMQ?
   3. Брокер предоставляет способы доставки сообщений exactly-once, at-most-once, at-least-once - в чем их разница?

#### **Задачи (middle)**

<blockquote style="background-color: #e6f7ff;">
  <strong>Задача 1:</strong> У нас 2 домена - заказы и delivery. Как нам синхронизировать статус и выполнение распределенного процесса между системами?
  <ul>
    <li>Нужен оркестратор (SAGA) или хореография. В чем их плюсы и минусы?</li>
    <li>Где можно расположить логику оркестрации? (на клиенте если stateless, в домене orders, в отдельном сервисе если stateful)</li>
  </ul>
</blockquote>


<blockquote style="background-color: #e6f7ff;">
  <strong>Задача 2:</strong> Юзера нужно уведомлять об изменении статуса по карте. Какие есть способы?
  <ul>
    <li>сам юзер обновляет статус</li>
    <li>polling и long polling</li>
    <li>websocket stream</li>
  </ul>
</blockquote>


#### **Опционально доп вопросы (middle+/senior)** 

Посмотрим что надо добавить если кол-во юзеров/запросов резко масштабируется?

1. Как ограничить нагрузку? (через rate limiter)
2. Как избежать от дублирования запросов в системе? 
   1. обеспечить идемпотентность при обработке. Идемпотентность хорошо работает, когда наш запрос не дошел и мы отправили новый. А что делать когда запрос дошел и успешно обработался на сервере, но мы не получили его ответ? (с подвохом)
   2. обеспечить защиту на фронте
   3. обеспечить обработку неуспешных запросов через retry (с тамаутами, без ответа, с ошибочными ответами)
3. Как обеспечить равномерную нагрузку на сервера/БД? 
   1. использовать вертикальное и горизонтальное масштабирование сервисов
   2. использовать кэш
   3. использовать шардирование БД. Как обеспечить равномерное распределение данных между шардами? (Hash-based через консистентное хэширование, Vertical, Range based)
4. Как избежать состояния гонки? У нас высокий параллелизм запросов к БД и возникают конфликты при записи одних и тех же значений. Как их избежать?
   1. оптимистичные, пессимистичные блокировки
   2. констрейнты БД и предикатные блокировки
   3. скрипт Lua
   4. упорядоченные множества Redis
5. Как обеспечить доступность и надежность - репликация по разным ЦОД (всего четное число для корректной работы алгоритмов согласованности)
6. Как обеспечить согласованность данных в системе? 
   1. по кворуму части голосов от реплик. Можно регулировать от слабой до сильной согласованности. Есть разные алгоритмы



## 3. Определим взаимодействие между системами (15 мин)

1. Составим примерный DTO JSON (нужно пошарить экран и блокнот)
```json
{
    "orderId": "00000000",  //его можно использовать для идемпотентности?
    "cardInfo": [],
    "userInfo": [],
    "ligalInfo": [],
    "deliveryInfo": [],
    "timestamp": "1023920310232327"
}
```

2. Какой протокол или несколько выберем для нашей системы? **rest / rpc / grpc / graphql / soap**
3. Распишем примерный контракт взаимодействия с заявкой (на выбранном протоколе)
   1. если выбрал REST то смотрим на правильную структуру запроса как ресурс /api/v1/order и правильный выбор методов POST, GET итд
   2. если выбрал rpc то смотрим на правильный выбор команд
   3. как версионировать запросы?
   4. где в запросе можно передавать параметры? (path, query, boby, header)

#### **Задачи**

<blockquote style="background-color: #e6f7ff;">
  <strong>Задача 1:</strong> У нас есть контракт от джуна - надо поревьюить и найти несколько ошибок <a href="https://raw.githubusercontent.com/konkrr/hiring-tasks/main/card-delivery-openapi.yaml">swagger</a>
</blockquote>



## 4. Определим модель данных (10 мин)

1. Выберем БД. Разрабы говорят что надо нормализовать БД а аналитики DWH говорят что надо все в одну таблицу сложить - кого слушать?  
   1. реляционные БД - репликация и сегментирование обеспечат масштабирование и доступность. 
   2. key-value БД - объектные или файло-хранилища с распределенными данными
   3. колоночные БД используем для событийных данных и аналитики

2. Давай раскидаем данные по таблицам в БД (используем наше DTO). 
   1. *orders_table*
   2. *users_table*
   3. *cards_table*
   4. *deliveries_table*

#### **Задачи**

>**Задача 1:** Менеджер просит: подсчитать кол-во уникальных пользователей из таблицы users, которые имеют карту card_type с типом 'credit' (представим, что БД денормализована)
>'''sql
>select count(distinct user_id) from users
>where card_type = 'credit'
>'''


#### **Опционально доп вопросы (middle+/senior)** 

1. В чем смысл теорем ACID, CAP?
2. Как обеспечить согласованность распределенных транзакций?
    1. Монопольная блокировка - для «грязных» записи/чтения. 
    2. 2PL двухфазная блокировка/коммит - монопольная блокировка для записи и разделяемая для чтения.  
    3. 2PC двухфазный commit - сначала проверка фиксации, потом фиксация. Для этого нужен координатор, который надо реплицировать, чтобы не был SPOF.
    4. XA-транзакции (SAGA) - пошаговое выполнение с прерываниями на ожидание решения. Сложный механизм, как эффект домино в случае отмены, эффективнее event-source подход. 
3. Что такое монотонное чтение и монотонная запись?
   1. Монотонное чтение - читаем всегда последнее сообщение. Снуружи выглядит как будто работаем с одной репликой без конкурентов 
   2. Монотонная запись - запись всегда происходит в порядке появления событий. Упорядочивание сообщений есть на уровне TCP или на апликейшн уровне
4. Что такое Eventual Consistency (PRAM)?
5. Как решить проблему мгновенного чтения своих событий? 
   1. Либо через кэш, который инвалидируется после репликации. 
   2. Либо в реплику чтения данные пишутся параллельно с записью. 


